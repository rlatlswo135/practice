function name(){return 'name'} //얘는 아직 함수를 값으로 취급하지않았기때문에 '문'이다 

//이름이 없는함수가 있다. 어떻게호출? -> 그 함수를 호출할 방법이없다.근데 js는 언어레벨에서 함수를 '값'취급하기때문에 변수에 넣을수있다 그러니 이름이없는함수를 변수에넣어서 쓸수있다는거지.

const nameV2 = function(){return '공백'} //이제부터 변수의이름이 이 익명함수의 이름을 대신하게된다 -> nameV2(); 함수가 '값'으로써 변수에 들어갔기때문에 '식'이다

//즉시실행함수

(function(){console.log('단한번만 실행')})(); //일단 익명함수를 만들었다 -> ()로 감싼다, 즉 함수를 '값'으로 만들고 -> (); 호출한다.

//이렇게되면 저 익명함수를 다음에 또 호출할수있을까? -> 불가능. 익명이니까 호출을못한다. 그 함수를 만들엇을때 바로 값으로바꾸고 호출을 햇으면 그함수는 두번다시 호출할 길이없는거다(익명이니까)

//가변인자

const sum = function(a,b,c){ // => (...args) => 명확히 함수사용자가 가변인자라는내용을 정확히 알수가있다. 몇개의 인자는 필수값으로 그뒤는 가변인자로 (a,b,...args) 이런거도 가능
    let result = 0;
    for(let key of arguments){ //for(let key of args)
        result += key;
    }
    return result
}

console.log(sum(1,2,3,4,5,6)) //js는 함수의 인자가 정해졋다해서 정해진거보다 인자를 많이 ,적게 ,하나도 안넣어도 호출은 잘된다

/*
그래서 암묵적으로 arguments라는 변수에 해당 함수에 들어온 인자들이 배열로써 들어오게된다 그래서 저렇게된거. 하지만 함수를 겉모습으로 딱 봣을때 받는게 가변인자인지
한눈에 보기 어렵다 그래서 전개인자 구문을 쓴다 (...arg) 이러면 인자들이 arg라는 인자이름에 배열안에 들어있다라는 뜻이되니까 가변인자인지 딱보이겟지 몇개의 인자가 들어오든 arg라는
배열에 담길것이다
*/

//셋다 같은 함수호출인데 call과 apply는 약간 다른점이있다
sum();
sum.call(null,1,2,3,4); 
sum.apply(null,[1,2,3,4]); //첫번째 인자는 context객체를 받고(context세션때 참조) 두번째 인자는 그 함수에 들어갈 인자가 오는데 call은 값이오고 apply는 배열로써 값이온다

//그러니 call을써서 호출한 함수에 인자를 바꾸려면 함수호출식자체가 바뀌겟지만 apply를 쓴 호출식은 해당 배열을 변수로써 담아놓은 코드줄이있다면 그 줄만변경해도되니 차이가 분명히있다.

// -- 생성기함수 --

function* gen(){ //yield = generator함수만의 return이라 생각하면될듯.
    yield 10;
    yield 20;
    return 30;
}
//일반적인함수호출을 하면 함수내 코드 1번째부터 쭉실행되고 다시호출해도 그 과정이 반복하는게 일반적인데 gen함수는 마치 핑퐁하는것처럼 된다 10 -> 20 -> 30 좀 어려운개념.
gen.next() // 10
gen.next() // 20
gen.next() // 30

//gen함수를 만들면 즉 그 generator함수를 실행시킬수있는 도구가 팅겨나오는데 그 도구안에 next라는 메쏘드로 해당 gen함수를 실행시킨다.

// -- 비동기 함수 --  ====> 추후 context객체 promise함수 callback(일급함수) 등 이해후 다시와보자

async function myTask(){

}

