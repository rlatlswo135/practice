function name(){return 'name'} //얘는 아직 함수를 값으로 취급하지않았기때문에 '문'이다 

//이름이 없는함수가 있다. 어떻게호출? -> 그 함수를 호출할 방법이없다.근데 js는 언어레벨에서 함수를 '값'취급하기때문에 변수에 넣을수있다 그러니 이름이없는함수를 변수에넣어서 쓸수있다는거지.

const nameV2 = function(){return '공백'} //이제부터 변수의이름이 이 익명함수의 이름을 대신하게된다 -> nameV2(); 함수가 '값'으로써 변수에 들어갔기때문에 '식'이다

//즉시실행함수

(function(){console.log('단한번만 실행')})(); //일단 익명함수를 만들었다 -> ()로 감싼다, 즉 함수를 '값'으로 만들고 -> (); 호출한다.

//이렇게되면 저 익명함수를 다음에 또 호출할수있을까? -> 불가능. 익명이니까 호출을못한다. 그 함수를 만들엇을때 바로 값으로바꾸고 호출을 햇으면 그함수는 두번다시 호출할 길이없는거다(익명이니까)

//가변인자

const sum = function(a,b,c){ // => (...args) => 명확히 함수사용자가 가변인자라는내용을 정확히 알수가있다. 몇개의 인자는 필수값으로 그뒤는 가변인자로 (a,b,...args) 이런거도 가능
    let result = 0;
    for(let key of arguments){ //for(let key of args)
        result += key;
    }
    return result
}

console.log(sum(1,2,3,4,5,6)) //js는 함수의 인자가 정해졋다해서 정해진거보다 인자를 많이 ,적게 ,하나도 안넣어도 호출은 잘된다

/*
그래서 암묵적으로 arguments라는 변수에 해당 함수에 들어온 인자들이 배열로써 들어오게된다 그래서 저렇게된거. 하지만 함수를 겉모습으로 딱 봣을때 받는게 가변인자인지
한눈에 보기 어렵다 그래서 전개인자 구문을 쓴다 (...arg) 이러면 인자들이 arg라는 인자이름에 배열안에 들어있다라는 뜻이되니까 가변인자인지 딱보이겟지 몇개의 인자가 들어오든 arg라는
배열에 담길것이다
*/

sum();
sum.call();
sum.apply();
